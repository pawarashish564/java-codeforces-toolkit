{
  "ModInt": {
    "prefix": "mod",
    "body": [
      "static long mod=${1:(long)1e9+7};",
      "",
      "static long add(long a, long b) {",
      "\treturn (a + b) % mod;",
      "}",
      "",
      "static long sub(long a, long b) {",
      "\tlong d = a - b;",
      "\twhile (d < 0)",
      "\t\td += mod;",
      "\treturn d;",
      "}",
      "",
      "static long mul(long a, long b) {",
      "\treturn a * b % mod;",
      "}",
      "",
      "static long div(long a, long b) {",
      "\treturn a * mod_inverse(b) % mod;",
      "}",
      "",
      "public static long[] fact(int n) {",
      "\tlong[] ret = new long[n + 1];",
      "\tret[0] = 1 % mod;",
      "\tfor (int i = 1; i <= n; i++) {",
      "\t\tret[i] = mul(ret[i - 1], i);",
      "\t}",
      "\treturn ret;",
      "}",
      "",
      "private static long[] factInv(int n) {",
      "\tlong[] ret = new long[n + 1];",
      "\tret[0] = 1;",
      "\tfor (int i = 1; i <= n; i++) {",
      "\t\tret[i] = div(ret[i - 1], i);",
      "\t}",
      "\treturn ret;",
      "}",
      "",
      "public static long comb(int n, int m, long[] fact, long[] factInv) {",
      "\tlong ret = fact[n];",
      "\tret = mul(ret, factInv[m]);",
      "\tret = mul(ret, factInv[n - m]);",
      "\treturn ret;",
      "}",
      "",
      "public static long[][] stirling(int n) {",
      "\tlong[][] ret = new long[n + 1][n + 1];",
      "\tret[0][0] = 1;",
      "\tfor (int i = 1; i <= n; i++)",
      "\t\tfor (int j = 1; j <= i; j++)",
      "\t\t\tret[i][j] = add(ret[i - 1][j - 1], mul(ret[i - 1][j], j));",
      "\treturn ret;",
      "}",
      "",
      "public static long mod_inverse(long a) {",
      "\tlong[] ret = extgcd(a, mod);",
      "\treturn add(mod, ret[0] % mod);",
      "}",
      "",
      "private static long[] extgcd(long a, long b) {",
      "\tlong[] ret = new long[3];",
      "\tret[2] = _extgcd(a, b, ret);",
      "\treturn ret;",
      "}",
      "",
      "private static long _extgcd(long a, long b, long[] x) {",
      "\tlong g = a;",
      "\tx[0] = 1;",
      "\tx[1] = 0;",
      "\tif (b != 0) {",
      "\t\tg = _extgcd(b, a % b, x);",
      "\t\tlong temp = x[0];",
      "\t\tx[0] = x[1];",
      "\t\tx[1] = temp;",
      "\t\tx[1] -= (a / b) * x[0];",
      "\t}",
      "\treturn g;",
      "}",
      "",
      "static long modpow(long a, long n) {",
      "\tlong res = 1;",
      "\twhile (n > 0) {",
      "\t\tif ((n & 1) != 0)",
      "\t\t\tres = res * a % mod;",
      "\t\ta = a * a % mod;",
      "\t\tn >>= 1;",
      "\t}",
      "\treturn res;",
      "}",
      ""
    ],
    "description": "Add, sub, mul, div (addition, subtraction, multiplication and division): O(1) fact (factorial): O(n) factInv (inverse factorial factor): O(nlogp) comb (combination): O( 1) (preliminary calculation O(nlogp)) mod_inverse (inverse element): O(logp) modpow (modulus of power): O(logp) stirling: O(n^2)"
  },
  "Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "public static long[] dijkstra(int s, Graph[] g) {",
      "\tlong[] d = new long[g.length];",
      "\tPriorityQueue<long[]> pq = new PriorityQueue<long[]>(new Comparator<long[]>() {",
      "\t\tpublic int compare(long[] a, long[] b) {",
      "\t\t\treturn Long.compare(a[1], b[1]);",
      "\t\t}",
      "\t});",
      "\tArrays.fill(d, 1L << 60);",
      "\td[s] = 0;",
      "\tpq.offer(new long[] { s, 0 });",
      "\twhile (!pq.isEmpty()) {",
      "\t\tlong[] p = pq.poll();",
      "\t\tint from = (int) p[0];",
      "\t\tif (d[from] != p[1])",
      "\t\t\tcontinue;",
      "\t\tfor (int i = 0; i < g[from].size(); i++) {",
      "\t\t\tlong[] e = g[from].get(i);",
      "\t\t\tint to = (int) e[0];",
      "\t\t\tif (d[to] > d[from] + e[1]) {",
      "\t\t\t\td[to] = d[from] + e[1];",
      "\t\t\t\tpq.offer(new long[] { to, d[to] });",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn d;",
      "}",
      "",
      "static class Graph extends ArrayList<long[]> {",
      "}",
      ""
    ],
    "description": "O(ElogV) for finding the shortest path from a single starting point"
  },
  "Disjoint Sparse Table": {
    "prefix": "disjoint",
    "body": [
      "static class DisjointSparseTable {",
      "\tBinaryOperator<Long> f;",
      "\tlong[][] dat;",
      "\tlong[] ht;",
      "",
      "\tDisjointSparseTable(BinaryOperator<Long> f, long[] v) {",
      "\t\tthis.f = f;",
      "\t\tint n = v.length, h = 1;",
      "\t\twhile ((1 << h) <= n)",
      "\t\t\th++;",
      "\t\tdat = new long[h][n];",
      "\t\tht = new long[(1 << h) + 1];",
      "\t\tfor (int j = 2; j < (1 << h) + 1; j++)",
      "\t\t\tht[j] = ht[j >> 1] + 1;",
      "\t\tfor (int j = 0; j < n; j++)",
      "\t\t\tdat[0][j] = v[j];",
      "\t\tfor (int i = 1; i < h; i++) {",
      "\t\t\tint s = 1 << i;",
      "\t\t\tfor (int j = 0; j < n; j += s << 1) {",
      "\t\t\t\tint t = Math.min(j + s, n);",
      "\t\t\t\tdat[i][t - 1] = v[t - 1];",
      "\t\t\t\tfor (int k = t - 2; k >= j; k--)",
      "\t\t\t\t\tdat[i][k] = f.apply(v[k], dat[i][k + 1]);",
      "\t\t\t\tif (n <= t)",
      "\t\t\t\t\tbreak;",
      "\t\t\t\tdat[i][t] = v[t];",
      "\t\t\t\tint r = Math.min(t + s, n);",
      "\t\t\t\tfor (int k = t + 1; k < r; k++)",
      "\t\t\t\t\tdat[i][k] = f.apply(dat[i][k - 1], v[k]);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "",
      "\t// [l,r)",
      "\tpublic long query(int l, int r) {",
      "\t\tif (l >= --r)",
      "\t\t\treturn dat[0][l];",
      "\t\treturn f.apply(dat[(int) ht[l ^ r]][l], dat[(int) ht[l ^ r]][r]);",
      "\t}",
      "",
      "\tpublic int length() {",
      "\t\treturn dat[0].length;",
      "\t}",
      "}",
      ""
    ],
    "description": "Operate f on static interval Construction: O(nlogn) query: O(1)"
  },
  "Topological Sort": {
    "prefix": "topological",
    "body": [
      "static int[] TopologicalSort(Graph[] g) {",
      "\tint n = g.length;",
      "\tint[] in = new int[n];",
      "\tint[] ord = new int[n];",
      "\tfor (int i = 0; i < n; i++) {",
      "\t\tfor (int to : gs[i])",
      "\t\t\tin[to]++;",
      "\t}",
      "\tDeque<Integer> s = new ArrayDeque<Integer>();",
      "\tfor (int i = 0; i < n; i++) {",
      "\t\tif (in[i] == 0) {",
      "\t\t\ts.offerFirst(i);",
      "\t\t}",
      "\t}",
      "\tint p = 0;",
      "\twhile (!s.isEmpty()) {",
      "\t\tint from = s.pollFirst();",
      "\t\tord[p++] = from;",
      "\t\tfor (int j = 0; j < g[from].size(); j++) {",
      "\t\t\tint to = g[from].get(j);",
      "\t\t\tin[to]--;",
      "\t\t\tif (in[to] == 0) {",
      "\t\t\t\ts.offerFirst(to);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tfor (int i = 0; i < n; i++)",
      "\t\tif (in[i] != 0)",
      "\t\t\treturn null;",
      "\treturn ord;",
      "}",
      "",
      "static class Graph extends ArrayList<Integer> {}",
      ""
    ],
    "description": "Topological sort O(V+E)"
  },
  "lower_bound": {
    "prefix": "lower_bound",
    "body": [
      "public static int lower_bound(long[] a, int fromIndex, int toIndex, long val) {",
      "\tif (val > a[toIndex])",
      "\t\treturn toIndex + 1;",
      "\tif (val <= a[fromIndex])",
      "\t\treturn fromIndex;",
      "\tint lb = fromIndex - 1, ub = toIndex;",
      "\twhile (ub - lb > 1) {",
      "\t\tint mid = (ub - lb)/2+lb;",
      "\t\tif (a[mid] >= val) {",
      "\t\t\tub = mid;",
      "\t\t} else {",
      "\t\t\tlb = mid;",
      "\t\t}",
      "\t}",
      "\treturn ub;",
      "}",
      ""
    ],
    "description": "Binary search (find the smallest i such that a[i]>=val) O(logn)"
  },
  "upper_bound": {
    "prefix": "upper_bound",
    "body": [
      "public static int upper_bound(long[] a, int fromIndex, int toIndex, long val) {",
      "\tif (val >= a[toIndex])",
      "\t\treturn toIndex + 1;",
      "\tif (val < a[fromIndex])",
      "\t\treturn fromIndex;",
      "\tint lb = fromIndex - 1, ub = toIndex;",
      "\twhile (ub - lb > 1) {",
      "\t\tint mid = (ub - lb)/2+lb;",
      "\t\tif (a[mid] > val) {",
      "\t\t\tub = mid;",
      "\t\t} else {",
      "\t\t\tlb = mid;",
      "\t\t}",
      "\t}",
      "\treturn ub;",
      "}",
      ""
    ],
    "description": "Binary search (find the smallest i such that a[i]>val) O(logn)"
  },
  "Segment Tree": {
    "prefix": "SegmentTree",
    "body": [
      "static class SegmentTree {",
      "",
      "\tBinaryOperator<Long> f;",
      "\tint n;",
      "\tlong[] seg;",
      "\tlong e;",
      "",
      "\tpublic SegmentTree(int nn, BinaryOperator<Long> f, long e) {",
      "\t\tthis.f = f;",
      "\t\tthis.e = e;",
      "\t\tn = 1;",
      "\t\twhile (n < nn)",
      "\t\t\tn <<= 1;",
      "\t\tseg = new long[n * 2 - 1];",
      "\t\tArrays.fill(seg, e);",
      "\t}",
      "",
      "\tpublic SegmentTree(long[] a, BinaryOperator<Long> f, long e) {",
      "\t\tthis.f = f;",
      "\t\tthis.e = e;",
      "\t\tn = 1;",
      "\t\twhile (n < a.length)",
      "\t\t\tn <<= 1;",
      "\t\tseg = new long[n * 2 - 1];",
      "\t\tArrays.fill(seg, e);",
      "\t\tfor (int i = 0; i < a.length; i++)",
      "\t\t\tseg[i + n - 1] = a[i];",
      "\t\tfor (int i = n - 2; i >= 0; i--)",
      "\t\t\tseg[i] = f.apply(seg[i * 2 + 1], seg[i * 2 + 2]);",
      "\t}",
      "",
      "\tpublic long query(int l, int r) {",
      "\t\treturn query(l, r, 0, 0, n);",
      "\t}",
      "",
      "\tprivate long query(int a, int b, int k, int l, int r) {",
      "\t\tif (a <= l && r <= b)",
      "\t\t\treturn seg[k];",
      "\t\tif (r <= a || b <= l)",
      "\t\t\treturn e;",
      "\t\tlong vl = query(a, b, k * 2 + 1, l, (l + r) / 2);",
      "\t\tlong vr = query(a, b, k * 2 + 2, (l + r) / 2, r);",
      "\t\treturn f.apply(vl, vr);",
      "\t}",
      "",
      "\tvoid update(int i, int x) {",
      "\t\ti += n - 1;",
      "\t\tseg[i] = x;",
      "\t\twhile (i > 0) {",
      "\t\t\ti = (i - 1) / 2;",
      "\t\t\tseg[i] = f.apply(seg[i * 2 + 1], seg[i * 2 + 2]);",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Segment Tree :Operation f can be performed on the interval to update one element Construction: O(n) query:O(logn) update:O(logn)"
  },
  "UnionFindTree": {
    "prefix": "UF",
    "body": [
      "static class UnionFindTree {",
      "",
      "\tprivate int[] par;",
      "\tprivate int[] rank;",
      "\tprivate int g;",
      "",
      "\tpublic UnionFindTree(int size) {",
      "\t\tpar = new int[size];",
      "\t\trank = new int[size];",
      "\t\tg = size;",
      "\t\tfor (int i = 0; i < size; i++) {",
      "\t\t\tpar[i] = -1;",
      "\t\t\trank[i] = 0;",
      "\t\t}",
      "\t}",
      "",
      "\tpublic int find(int x) {",
      "\t\tif (par[x] < 0)",
      "\t\t\treturn x;",
      "\t\telse",
      "\t\t\treturn par[x] = find(par[x]);",
      "\t}",
      "",
      "\tpublic void unite(int x, int y) {",
      "\t\tx = find(x);",
      "\t\ty = find(y);",
      "\t\tif (x == y)",
      "\t\t\treturn;",
      "\t\telse if (rank[x] > rank[y]) {",
      "\t\t\tpar[x] += par[y];",
      "\t\t\tpar[y] = x;",
      "\t\t} else {",
      "\t\t\tpar[y] += par[x];",
      "\t\t\tpar[x] = y;",
      "\t\t\tif (rank[x] == rank[y])",
      "\t\t\t\trank[y]++;",
      "\t\t}",
      "\t\tg--;",
      "\t}",
      "",
      "\tpublic int groups(){",
      "\t\treturn g;",
      "\t}",
      "",
      "\tpublic int size(int x) {",
      "\t\treturn -par[find(x)];",
      "\t}",
      "",
      "\tpublic boolean same(int x, int y) {",
      "\t\treturn find(x) == find(y);",
      "\t}",
      "}",
      ""
    ],
    "description": "Prime set data structure find:O(α(n)) unite:O(α(n)) groups:O(1) size:O(1) same:O(α(n))"
  }
}